using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using MalwareHuntServer.DataProviders;
using MalwareHuntShared;
using MalwareHuntShared.Objects;

namespace MalwareHuntServer.Analysis
{
    public class AnalyticsEngine
    {
        static Thread m_analysisThread;
        const int ANALYSIS_INTERVAL = 10000;
        public static void Start()
        {
            m_analysisThread = new Thread(Perform);
            m_analysisThread.Start();
        }

        static void Perform()
        {
            while (!Program.s_cancelTokenSource.Token.IsCancellationRequested)
            {
                FileActivityAnlytics.Instance.PerformAnalytics();
                ModuleAnalytics.Instance.PerformAnalytics();
                MachineAnalytics.Instance.PerformAnalytics();
                Program.s_cancelTokenSource.Token.WaitHandle.WaitOne(ANALYSIS_INTERVAL);
            }
            
        }
    }
    public abstract class AbstractAnalyticsEngine<T> where T : AbstractAnalyticsEngine<T>, new()
    {
        const int ANALYSIS_INTERVAL = 1000;
        static T m_instance;
        Thread m_analysisThread;
        public static T Instance
        {
            get
            {
                if (m_instance == null)
                    m_instance = new T();
                return m_instance;
            }
        }
        

        public virtual void PerformAnalytics()
        {
            throw new NotImplementedException();
        }
    }

    public class FileActivityAnlytics : AbstractAnalyticsEngine<FileActivityAnlytics>
    {
        public override void PerformAnalytics()
        {
            var fileActList = new List<FileActivity>(FileActivitiesProvider.Instance.DataList);
            for (int i = 0; i < fileActList.Count; i++)
            {
                FileActivity fileAct = fileActList[i];
                if (fileAct.TypeOfFileActivity == FileActivityType.Created || fileAct.TypeOfFileActivity == FileActivityType.Renamed)
                {
                    fileAct.LevelOfActivity = ActivityLevel.High;
                }
                else if (fileAct.TypeOfFileActivity == FileActivityType.Changed)
                {
                    fileAct.LevelOfActivity = ActivityLevel.Medium;
                }
                else if (fileAct.TypeOfFileActivity == FileActivityType.Deleted)
                {
                    fileAct.LevelOfActivity = ActivityLevel.Low;
                }
            }

            FileActivitiesProvider.Instance.UpdateData(fileActList,true);

        }
    }

    public class ModuleAnalytics : AbstractAnalyticsEngine<ModuleAnalytics>
    {
        public override void PerformAnalytics()
        {
            var modList = new List<Module>(ModulesProvider.Instance.DataList);
            for (int i = 0; i < modList.Count; i++)
            {
                Module m = modList[i];
                var list = GlobalActivityProvider.DataList.Where(o => o.ModuleIDList.Contains(m.ID.ToString())).ToList();
                m.UpdateScore(list);
            }
            ModulesProvider.Instance.UpdateData(modList,true);
        }
    }

    public class MachineAnalytics:AbstractAnalyticsEngine<MachineAnalytics>
    {
        public override void PerformAnalytics()
        {
            try
            {
                var macList = new List<Machine>(MachinesProvider.Instance.DataList);
                for (int i = 0; i < macList.Count; i++)
                {
                    Machine m = macList[i];
                    var list = ModulesProvider.Instance.DataList.Where(o => o.MachineIDList.Contains(m.ID.ToString())).ToList();
                    var score  = m.UpdateScore(list);
                    AnalysisResult.SaveAnalyticsResult(new AnalysisResult() { MachineID = m.ID, MachineScore = score });
                }
                MachinesProvider.Instance.UpdateData(macList, true);
            }
            catch(Exception ex) { Logger.Log(ex); }
        }
    }
}
